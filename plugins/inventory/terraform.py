#!/usr/bin/env python3

import argparse
import json
import os
import re
from collections import defaultdict
from functools import wraps

VERSION = '0.0.1'


def tfstates(root=None):
    root = root or os.getcwd()
    for dirpath, _, filenames in os.walk(root):
        for name in filenames:
            if os.path.splitext(name)[-1] == '.tfstate':
                yield os.path.join(dirpath, name)


def iterresources(filenames):
    for filename in filenames:
        with open(filename, 'r') as json_file:
            state = json.load(json_file)
            for module in state['modules']:
                if 'resources' not in module:
                    continue

                name = module['path'][-1]
                module['name'] = name

                for key, resource in module['resources'].items():
                    yield module, key, resource


def parse_nat_map(resources):
    """get a dictionary mapping private IP addresses to public ones"""

    nat_map = {}
    for module, key, resource in resources:
        resource_type, name = key.split('.', 1)
        if resource_type != 'ddcloud_nat':
            continue

        attributes = resource['primary']['attributes']
        private_ipv4 = attributes['private_ipv4']
        public_ipv4 = attributes['public_ipv4']

        nat_map[private_ipv4] = public_ipv4

    return nat_map


def iterhosts(resources):
    """yield host tuples of (name, attributes, groups)"""

    resources = list(resources)
    nat_map = parse_nat_map(resources)
    for module, key, resource in resources:
        resource_type, name = key.split('.', 1)
        if resource_type != 'ddcloud_server':
            continue

        parsed = parse_ddcloud_server(resource, module, nat_map)

        yield parsed


def calculate_mantl_vars(func):
    """calculate Mantl vars"""

    @wraps(func)
    def inner(*args, **kwargs):
        name, attrs, groups = func(*args, **kwargs)

        # attrs
        if attrs.get('role', '') == 'control':
            attrs['consul_is_server'] = True
        else:
            attrs['consul_is_server'] = False

        # groups
        if attrs.get('publicly_routable', False):
            groups.append('publicly_routable')

        return name, attrs, groups

    return inner


@calculate_mantl_vars
def parse_ddcloud_server(resource, module, nat_map):
    name = resource['primary']['attributes']['name']
    raw_attrs = resource['primary']['attributes']

    groups = []

    role = module['outputs']['role']['value']
    dcname = module['outputs']['consul_dc']['value']

    private_ipv4 = raw_attrs['primary_adapter_ipv4']
    try:
        public_ipv4 = nat_map[private_ipv4]
    except KeyError:
        public_ipv4 = private_ipv4

    attrs = {
        'id': raw_attrs['id'],

        # ansible-specific
        'ansible_ssh_port': 22,
        'ansible_ssh_user': 'root',
        'ansible_ssh_host': public_ipv4,

        # generic
        'public_ipv4': public_ipv4,
        'private_ipv4': private_ipv4,
        'provider': 'ddcloud',

        # Mantl
        'role': role,
        'consul_dc': dcname
    }
    if public_ipv4 == private_ipv4:
        del attrs['public_ipv4']

    # Groups specific to Mantl
    groups.append('role=' + attrs['role'])

    return name, attrs, groups


# QUERY TYPES
def query_host(hosts, target):
    for name, attrs, _ in hosts:
        if name == target:
            return attrs

    return {}


def query_list(hosts):
    groups = defaultdict(dict)
    meta = {}

    for name, attrs, hostgroups in hosts:
        for group in set(hostgroups):
            groups[group].setdefault('hosts', [])
            groups[group]['hosts'].append(name)

        meta[name] = attrs

    groups['_meta'] = {'hostvars': meta}

    return groups


def query_hostfile(hosts):
    out = ['## begin hosts generated by terraform.py ##']
    out.extend(
        '{}\t{}'.format(attrs['ansible_ssh_host'].ljust(16), name)
        for name, attrs, _ in hosts
    )

    out.append('## end hosts generated by terraform.py ##')
    return '\n'.join(out)


def main():
    parser = argparse.ArgumentParser(
        os.path.split(__file__)[-1],
        __doc__,
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )

    modes = parser.add_mutually_exclusive_group(required=True)
    modes.add_argument('--list',
                       action='store_true',
                       help='list all variables')
    modes.add_argument('--host', help='list variables for a single host')
    modes.add_argument('--version',
                       action='store_true',
                       help='print version and exit')
    modes.add_argument('--hostfile',
                       action='store_true',
                       help='print hosts as a /etc/hosts snippet')

    parser.add_argument('--pretty',
                        action='store_true',
                        help='pretty-print output JSON')
    parser.add_argument('--nometa',
                        action='store_true',
                        help='with --list, exclude hostvars')
    default_root = os.environ.get('TERRAFORM_STATE_ROOT',
                                  os.path.abspath(os.path.join(os.path.dirname(__file__),
                                                               '..', '..', )))
    parser.add_argument('--root',
                        default=default_root,
                        help='custom root to search for `.tfstate`s in')

    args = parser.parse_args()

    if args.version:
        print('%s %s' % (__file__, VERSION))
        parser.exit()

    hosts = iterhosts(
        iterresources(tfstates(args.root))
    )

    if args.list:
        output = query_list(hosts)
        if args.nometa:
            del output['_meta']
        print(json.dumps(output, indent=4 if args.pretty else None))
    elif args.host:
        output = query_host(hosts, args.host)
        print(json.dumps(output, indent=4 if args.pretty else None))
    elif args.hostfile:
        output = query_hostfile(hosts)
        print(output)

    parser.exit()


if __name__ == '__main__':
    main()
